{"ast":null,"code":"import { InjectionToken, EventEmitter, Directive, ViewContainerRef, Inject, Renderer2, Optional, Input, Output, HostListener, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { Subscription, fromEvent, merge } from 'rxjs';\nimport { mergeMap, map, takeUntil } from 'rxjs/operators';\nimport * as ɵngcc0 from '@angular/core';\n\nclass SlimScrollEvent {\n  constructor(obj) {\n    this.type = obj.type;\n    this.y = obj && obj.y ? obj.y : 0;\n    this.percent = obj && obj.percent ? obj.percent : 0;\n    this.duration = obj && obj.duration ? obj.duration : 0;\n    this.easing = obj && obj.easing ? obj.easing : 'linear';\n  }\n\n}\n\nconst SLIMSCROLL_DEFAULTS = new InjectionToken('NGX_SLIMSCROLL_DEFAULTS');\n\nclass SlimScrollOptions {\n  constructor(obj) {\n    this.position = obj && obj.position ? obj.position : 'right';\n    this.barBackground = obj && obj.barBackground ? obj.barBackground : '#343a40';\n    this.barOpacity = obj && obj.barOpacity ? obj.barOpacity : '1';\n    this.barWidth = obj && obj.barWidth ? obj.barWidth : '12';\n    this.barBorderRadius = obj && obj.barBorderRadius ? obj.barBorderRadius : '5';\n    this.barMargin = obj && obj.barMargin ? obj.barMargin : '0 0 0 0';\n    this.gridBackground = obj && obj.gridBackground ? obj.gridBackground : '#adb5bd';\n    this.gridOpacity = obj && obj.gridOpacity ? obj.gridOpacity : '1';\n    this.gridWidth = obj && obj.gridWidth ? obj.gridWidth : '8';\n    this.gridBorderRadius = obj && obj.gridBorderRadius ? obj.gridBorderRadius : '10';\n    this.gridMargin = obj && obj.gridMargin ? obj.gridMargin : '0 0 0 0';\n    this.alwaysVisible = obj && typeof obj.alwaysVisible !== 'undefined' ? obj.alwaysVisible : true;\n    this.visibleTimeout = obj && obj.visibleTimeout ? obj.visibleTimeout : 1000;\n    this.alwaysPreventDefaultScroll = obj && typeof obj.alwaysPreventDefaultScroll !== 'undefined' ? obj.alwaysPreventDefaultScroll : true;\n  }\n\n  merge(obj) {\n    const result = new SlimScrollOptions();\n    result.position = obj && obj.position ? obj.position : this.position;\n    result.barBackground = obj && obj.barBackground ? obj.barBackground : this.barBackground;\n    result.barOpacity = obj && obj.barOpacity ? obj.barOpacity : this.barOpacity;\n    result.barWidth = obj && obj.barWidth ? obj.barWidth : this.barWidth;\n    result.barBorderRadius = obj && obj.barBorderRadius ? obj.barBorderRadius : this.barBorderRadius;\n    result.barMargin = obj && obj.barMargin ? obj.barMargin : this.barMargin;\n    result.gridBackground = obj && obj.gridBackground ? obj.gridBackground : this.gridBackground;\n    result.gridOpacity = obj && obj.gridOpacity ? obj.gridOpacity : this.gridOpacity;\n    result.gridWidth = obj && obj.gridWidth ? obj.gridWidth : this.gridWidth;\n    result.gridBorderRadius = obj && obj.gridBorderRadius ? obj.gridBorderRadius : this.gridBorderRadius;\n    result.gridMargin = obj && obj.gridMargin ? obj.gridMargin : this.gridMargin;\n    result.alwaysVisible = obj && typeof obj.alwaysVisible !== 'undefined' ? obj.alwaysVisible : this.alwaysVisible;\n    result.visibleTimeout = obj && obj.visibleTimeout ? obj.visibleTimeout : this.visibleTimeout;\n    result.alwaysPreventDefaultScroll = obj && typeof obj.alwaysPreventDefaultScroll !== 'undefined' ? obj.alwaysPreventDefaultScroll : true;\n    return result;\n  }\n\n}\n\nclass SlimScrollState {\n  constructor(obj) {\n    this.scrollPosition = obj && obj.scrollPosition ? obj.scrollPosition : 0;\n    this.isScrollAtStart = obj && typeof obj.isScrollAtStart !== 'undefined' ? obj.isScrollAtStart : true;\n    this.isScrollAtEnd = obj && typeof obj.isScrollAtEnd !== 'undefined' ? obj.isScrollAtEnd : false;\n  }\n\n}\n\nconst ɵ0 = t => t,\n      ɵ1 = t => t * t,\n      ɵ2 = t => t * (2 - t),\n      ɵ3 = t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,\n      ɵ4 = t => t * t * t,\n      ɵ5 = t => --t * t * t + 1,\n      ɵ6 = t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,\n      ɵ7 = t => t * t * t * t,\n      ɵ8 = t => 1 - --t * t * t * t,\n      ɵ9 = t => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t,\n      ɵ10 = t => t * t * t * t * t,\n      ɵ11 = t => 1 + --t * t * t * t * t,\n      ɵ12 = t => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n\nconst easing = {\n  linear: ɵ0,\n  inQuad: ɵ1,\n  outQuad: ɵ2,\n  inOutQuad: ɵ3,\n  inCubic: ɵ4,\n  outCubic: ɵ5,\n  inOutCubic: ɵ6,\n  inQuart: ɵ7,\n  outQuart: ɵ8,\n  inOutQuart: ɵ9,\n  inQuint: ɵ10,\n  outQuint: ɵ11,\n  inOutQuint: ɵ12\n};\nlet SlimScrollDirective = /*#__PURE__*/(() => {\n  class SlimScrollDirective {\n    constructor(viewContainer, renderer, document, optionsDefaults) {\n      this.viewContainer = viewContainer;\n      this.renderer = renderer;\n      this.document = document;\n      this.optionsDefaults = optionsDefaults;\n      this.enabled = true;\n      this.scrollChanged = new EventEmitter();\n      this.barVisibilityChange = new EventEmitter();\n      this.el = this.viewContainer.element.nativeElement;\n      this.body = this.document.querySelector('body');\n      this.mutationThrottleTimeout = 50;\n    }\n\n    ngOnInit() {\n      if (!this.interactionSubscriptions && this.enabled) {\n        this.setup();\n      }\n    }\n\n    ngOnChanges(changes) {\n      if (changes.enabled) {\n        if (this.enabled) {\n          this.setup();\n        } else {\n          this.destroy();\n        }\n      }\n\n      if (changes.options) {\n        this.destroy();\n        this.setup();\n      }\n    }\n\n    ngOnDestroy() {\n      this.destroy();\n    }\n\n    setup() {\n      this.interactionSubscriptions = new Subscription();\n\n      if (this.optionsDefaults) {\n        this.options = new SlimScrollOptions(this.optionsDefaults).merge(this.options);\n      } else {\n        this.options = new SlimScrollOptions(this.options);\n      }\n\n      this.setStyle();\n      this.wrapContainer();\n      this.initGrid();\n      this.initBar();\n      this.getBarHeight();\n      this.initWheel();\n      this.initDrag();\n\n      if (!this.options.alwaysVisible) {\n        this.hideBarAndGrid();\n      }\n\n      if (MutationObserver) {\n        if (this.mutationObserver) {\n          this.mutationObserver.disconnect();\n        }\n\n        this.mutationObserver = new MutationObserver(() => {\n          if (this.mutationThrottleTimeout) {\n            clearTimeout(this.mutationThrottleTimeout);\n            this.mutationThrottleTimeout = setTimeout(this.onMutation.bind(this), 50);\n          }\n        });\n        this.mutationObserver.observe(this.el, {\n          subtree: true,\n          childList: true\n        });\n      }\n\n      if (this.scrollEvents && this.scrollEvents instanceof EventEmitter) {\n        const scrollSubscription = this.scrollEvents.subscribe(event => this.handleEvent(event));\n        this.interactionSubscriptions.add(scrollSubscription);\n      }\n    }\n\n    handleEvent(e) {\n      if (e.type === 'scrollToBottom') {\n        const y = this.el.scrollHeight - this.el.clientHeight;\n        this.scrollTo(y, e.duration, e.easing);\n      } else if (e.type === 'scrollToTop') {\n        const y = 0;\n        this.scrollTo(y, e.duration, e.easing);\n      } else if (e.type === 'scrollToPercent' && e.percent >= 0 && e.percent <= 100) {\n        const y = Math.round((this.el.scrollHeight - this.el.clientHeight) / 100 * e.percent);\n        this.scrollTo(y, e.duration, e.easing);\n      } else if (e.type === 'scrollTo') {\n        const max = this.el.scrollHeight - this.el.clientHeight;\n        const y = e.y <= max ? e.y : max;\n\n        if (y >= 0) {\n          this.scrollTo(y, e.duration, e.easing);\n        }\n      } else if (e.type === 'recalculate') {\n        this.getBarHeight();\n      }\n    }\n\n    setStyle() {\n      const el = this.el;\n      this.renderer.setStyle(el, 'overflow', 'hidden');\n    }\n\n    onMutation() {\n      this.getBarHeight();\n      this.setBarTop();\n    }\n\n    wrapContainer() {\n      this.wrapper = this.renderer.createElement('div');\n      const wrapper = this.wrapper;\n      const el = this.el;\n      this.renderer.addClass(wrapper, 'slimscroll-wrapper');\n      this.renderer.setStyle(wrapper, 'position', 'relative');\n      this.renderer.setStyle(wrapper, 'overflow', 'hidden');\n      this.renderer.setStyle(wrapper, 'display', 'block');\n      this.renderer.setStyle(wrapper, 'margin', getComputedStyle(el).margin);\n      this.renderer.setStyle(wrapper, 'width', '100%');\n      this.renderer.setStyle(wrapper, 'height', getComputedStyle(el).height);\n      this.renderer.insertBefore(el.parentNode, wrapper, el);\n      this.renderer.appendChild(wrapper, el);\n    }\n\n    initGrid() {\n      this.grid = this.renderer.createElement('div');\n      const grid = this.grid;\n      this.renderer.addClass(grid, 'slimscroll-grid');\n      this.renderer.setStyle(grid, 'position', 'absolute');\n      this.renderer.setStyle(grid, 'top', '0');\n      this.renderer.setStyle(grid, 'bottom', '0');\n      this.renderer.setStyle(grid, this.options.position, '0');\n      this.renderer.setStyle(grid, 'width', `${this.options.gridWidth}px`);\n      this.renderer.setStyle(grid, 'background', this.options.gridBackground);\n      this.renderer.setStyle(grid, 'opacity', this.options.gridOpacity);\n      this.renderer.setStyle(grid, 'display', 'block');\n      this.renderer.setStyle(grid, 'cursor', 'pointer');\n      this.renderer.setStyle(grid, 'z-index', '99');\n      this.renderer.setStyle(grid, 'border-radius', `${this.options.gridBorderRadius}px`);\n      this.renderer.setStyle(grid, 'margin', this.options.gridMargin);\n      this.renderer.appendChild(this.wrapper, grid);\n    }\n\n    initBar() {\n      this.bar = this.renderer.createElement('div');\n      const bar = this.bar;\n      this.renderer.addClass(bar, 'slimscroll-bar');\n      this.renderer.setStyle(bar, 'position', 'absolute');\n      this.renderer.setStyle(bar, 'top', '0');\n      this.renderer.setStyle(bar, this.options.position, '0');\n      this.renderer.setStyle(bar, 'width', `${this.options.barWidth}px`);\n      this.renderer.setStyle(bar, 'background', this.options.barBackground);\n      this.renderer.setStyle(bar, 'opacity', this.options.barOpacity);\n      this.renderer.setStyle(bar, 'display', 'block');\n      this.renderer.setStyle(bar, 'cursor', 'pointer');\n      this.renderer.setStyle(bar, 'z-index', '100');\n      this.renderer.setStyle(bar, 'border-radius', `${this.options.barBorderRadius}px`);\n      this.renderer.setStyle(bar, 'margin', this.options.barMargin);\n      this.renderer.appendChild(this.wrapper, bar);\n      this.barVisibilityChange.emit(true);\n    }\n\n    getBarHeight() {\n      const elHeight = this.el.offsetHeight;\n      const barHeight = Math.max(elHeight / this.el.scrollHeight * elHeight, 30) + 'px';\n      const display = parseInt(barHeight, 10) === elHeight ? 'none' : 'block';\n\n      if (this.wrapper.offsetHeight !== elHeight) {\n        this.renderer.setStyle(this.wrapper, 'height', elHeight + 'px');\n      }\n\n      this.renderer.setStyle(this.bar, 'height', barHeight);\n      this.renderer.setStyle(this.bar, 'display', display);\n      this.renderer.setStyle(this.grid, 'display', display);\n      this.barVisibilityChange.emit(display !== 'none');\n    }\n\n    scrollTo(y, duration, easingFunc) {\n      const start = Date.now();\n      const from = this.el.scrollTop;\n      const paddingTop = parseInt(this.el.style.paddingTop, 10) || 0;\n      const paddingBottom = parseInt(this.el.style.paddingBottom, 10) || 0;\n\n      const scroll = () => {\n        const currentTime = Date.now();\n        const time = Math.min(1, (currentTime - start) / duration);\n        const easedTime = easing[easingFunc](time);\n\n        if (paddingTop > 0 || paddingBottom > 0) {\n          let fromY = null;\n\n          if (paddingTop > 0) {\n            fromY = -paddingTop;\n            fromY = -(easedTime * (y - fromY) + fromY);\n            this.renderer.setStyle(this.el, 'padding-top', `${fromY}px`);\n          }\n\n          if (paddingBottom > 0) {\n            fromY = paddingBottom;\n            fromY = easedTime * (y - fromY) + fromY;\n            this.renderer.setStyle(this.el, 'padding-bottom', `${fromY}px`);\n          }\n        } else {\n          this.el.scrollTop = easedTime * (y - from) + from;\n        }\n\n        this.setBarTop();\n        this.saveCurrent();\n        this.updateScrollState();\n\n        if (time < 1) {\n          requestAnimationFrame(scroll);\n        }\n      };\n\n      if (!duration || !easingFunc) {\n        this.el.scrollTop = y;\n        this.setBarTop();\n        this.saveCurrent();\n        this.updateScrollState();\n      } else {\n        requestAnimationFrame(scroll);\n      }\n    }\n\n    scrollContent(y, isWheel, isJump) {\n      let delta = y;\n      const maxTop = this.el.offsetHeight - this.bar.offsetHeight;\n      const hiddenContent = this.el.scrollHeight - this.el.offsetHeight;\n      let percentScroll;\n      let over = null;\n\n      if (isWheel) {\n        delta = parseInt(getComputedStyle(this.bar).top, 10) + y * 20 / 100 * this.bar.offsetHeight;\n\n        if (delta < 0 || delta > maxTop) {\n          over = delta > maxTop ? delta - maxTop : delta;\n        }\n\n        delta = Math.min(Math.max(delta, 0), maxTop);\n        delta = y > 0 ? Math.ceil(delta) : Math.floor(delta);\n        this.renderer.setStyle(this.bar, 'top', delta + 'px');\n      }\n\n      percentScroll = parseInt(getComputedStyle(this.bar).top, 10) / (this.el.offsetHeight - this.bar.offsetHeight);\n      delta = percentScroll * hiddenContent;\n      this.el.scrollTop = delta;\n      this.showBarAndGrid();\n\n      if (!this.options.alwaysVisible) {\n        if (this.visibleTimeout) {\n          clearTimeout(this.visibleTimeout);\n        }\n\n        this.visibleTimeout = setTimeout(() => {\n          this.hideBarAndGrid();\n        }, this.options.visibleTimeout);\n      }\n\n      this.updateScrollState();\n      this.saveCurrent();\n      return over;\n    }\n\n    updateScrollState() {\n      const isScrollAtStart = this.el.scrollTop === 0;\n      const isScrollAtEnd = this.el.scrollTop === this.el.scrollHeight - this.el.offsetHeight;\n      const scrollPosition = Math.ceil(this.el.scrollTop);\n      const scrollState = new SlimScrollState({\n        scrollPosition,\n        isScrollAtStart,\n        isScrollAtEnd\n      });\n      this.scrollChanged.emit(scrollState);\n    }\n\n    initWheel() {\n      const dommousescroll = fromEvent(this.el, 'DOMMouseScroll');\n      const mousewheel = fromEvent(this.el, 'mousewheel');\n      const wheelSubscription = merge(...[dommousescroll, mousewheel]).subscribe(e => {\n        let delta = 0;\n\n        if (e.wheelDelta) {\n          delta = -e.wheelDelta / 120;\n        }\n\n        if (e.detail) {\n          delta = e.detail / 3;\n        }\n\n        const over = this.scrollContent(delta, true, false);\n\n        if (e.preventDefault && (this.options.alwaysPreventDefaultScroll || over === null)) {\n          e.preventDefault();\n        }\n      });\n      this.interactionSubscriptions.add(wheelSubscription);\n    }\n\n    initDrag() {\n      const bar = this.bar;\n      const mousemove = fromEvent(this.document.documentElement, 'mousemove');\n      const touchmove = fromEvent(this.document.documentElement, 'touchmove');\n      const mousedown = fromEvent(bar, 'mousedown');\n      const touchstart = fromEvent(this.el, 'touchstart');\n      const mouseup = fromEvent(this.document.documentElement, 'mouseup');\n      const touchend = fromEvent(this.document.documentElement, 'touchend');\n      const mousedrag = mousedown.pipe(mergeMap(e => {\n        this.pageY = e.pageY;\n        this.top = parseFloat(getComputedStyle(bar).top);\n        return mousemove.pipe(map(emove => {\n          emove.preventDefault();\n          return this.top + emove.pageY - this.pageY;\n        }), takeUntil(mouseup));\n      }));\n      const touchdrag = touchstart.pipe(mergeMap(e => {\n        this.pageY = e.targetTouches[0].pageY;\n        this.top = -parseFloat(getComputedStyle(bar).top);\n        return touchmove.pipe(map(tmove => {\n          return -(this.top + tmove.targetTouches[0].pageY - this.pageY);\n        }), takeUntil(touchend));\n      }));\n      const dragSubscription = merge(...[mousedrag, touchdrag]).subscribe(top => {\n        this.body.addEventListener('selectstart', this.preventDefaultEvent, false);\n        this.renderer.setStyle(this.body, 'touch-action', 'pan-y');\n        this.renderer.setStyle(this.body, 'user-select', 'none');\n        this.renderer.setStyle(this.bar, 'top', `${top}px`);\n        const over = this.scrollContent(0, true, false);\n        const maxTop = this.el.offsetHeight - this.bar.offsetHeight;\n\n        if (over && over < 0 && -over <= maxTop) {\n          this.renderer.setStyle(this.el, 'paddingTop', -over + 'px');\n        } else if (over && over > 0 && over <= maxTop) {\n          this.renderer.setStyle(this.el, 'paddingBottom', over + 'px');\n        }\n      });\n      const dragEndSubscription = merge(...[mouseup, touchend]).subscribe(() => {\n        this.body.removeEventListener('selectstart', this.preventDefaultEvent, false);\n        const paddingTop = parseInt(this.el.style.paddingTop, 10);\n        const paddingBottom = parseInt(this.el.style.paddingBottom, 10);\n        this.renderer.setStyle(this.body, 'touch-action', 'unset');\n        this.renderer.setStyle(this.body, 'user-select', 'default');\n\n        if (paddingTop > 0) {\n          this.scrollTo(0, 300, 'linear');\n        } else if (paddingBottom > 0) {\n          this.scrollTo(0, 300, 'linear');\n        }\n      });\n      this.interactionSubscriptions.add(dragSubscription);\n      this.interactionSubscriptions.add(dragEndSubscription);\n    }\n\n    setBarTop() {\n      const barHeight = Math.max(this.el.offsetHeight / this.el.scrollHeight * this.el.offsetHeight, 30);\n      const maxScrollTop = this.el.scrollHeight - this.el.clientHeight;\n      const paddingBottom = parseInt(this.el.style.paddingBottom, 10) || 0;\n      const percentScroll = this.el.scrollTop / maxScrollTop;\n\n      if (paddingBottom === 0) {\n        const delta = Math.round((this.el.clientHeight - barHeight) * percentScroll);\n\n        if (delta > 0) {\n          this.renderer.setStyle(this.bar, 'top', `${delta}px`);\n        }\n      }\n    }\n\n    saveCurrent() {\n      const max = this.el.scrollHeight - this.el.clientHeight;\n      const percent = this.el.scrollTop / max;\n      this.current = {\n        max,\n        percent\n      };\n    }\n\n    showBarAndGrid() {\n      this.renderer.setStyle(this.grid, 'background', this.options.gridBackground);\n      this.renderer.setStyle(this.bar, 'background', this.options.barBackground);\n    }\n\n    hideBarAndGrid() {\n      this.renderer.setStyle(this.grid, 'background', 'transparent');\n      this.renderer.setStyle(this.bar, 'background', 'transparent');\n    }\n\n    preventDefaultEvent(e) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    destroy() {\n      if (this.mutationObserver) {\n        this.mutationObserver.disconnect();\n        this.mutationObserver = null;\n      }\n\n      if (this.el.parentElement.classList.contains('slimscroll-wrapper')) {\n        const wrapper = this.el.parentElement;\n        const bar = wrapper.querySelector('.slimscroll-bar');\n        wrapper.removeChild(bar);\n        const grid = wrapper.querySelector('.slimscroll-grid');\n        wrapper.removeChild(grid);\n        this.unwrap(wrapper);\n      }\n\n      if (this.interactionSubscriptions) {\n        this.interactionSubscriptions.unsubscribe();\n      }\n    }\n\n    unwrap(wrapper) {\n      const docFrag = document.createDocumentFragment();\n\n      while (wrapper.firstChild) {\n        const child = wrapper.removeChild(wrapper.firstChild);\n        docFrag.appendChild(child);\n      }\n\n      wrapper.parentNode.replaceChild(docFrag, wrapper);\n    }\n\n    onResize() {\n      const {\n        percent\n      } = Object.assign({}, this.current);\n      this.destroy();\n      this.setup();\n      this.scrollTo(Math.round((this.el.scrollHeight - this.el.clientHeight) * percent), null, null);\n    }\n\n  }\n\n  SlimScrollDirective.ɵfac = function SlimScrollDirective_Factory(t) {\n    return new (t || SlimScrollDirective)(ɵngcc0.ɵɵdirectiveInject(ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(SLIMSCROLL_DEFAULTS, 8));\n  };\n\n  SlimScrollDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SlimScrollDirective,\n    selectors: [[\"\", \"slimScroll\", \"\"]],\n    hostBindings: function SlimScrollDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"resize\", function SlimScrollDirective_resize_HostBindingHandler() {\n          return ctx.onResize();\n        }, false, ɵngcc0.ɵɵresolveWindow);\n      }\n    },\n    inputs: {\n      enabled: \"enabled\",\n      options: \"options\",\n      scrollEvents: \"scrollEvents\"\n    },\n    outputs: {\n      scrollChanged: \"scrollChanged\",\n      barVisibilityChange: \"barVisibilityChange\"\n    },\n    exportAs: [\"slimScroll\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return SlimScrollDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgSlimScrollModule = /*#__PURE__*/(() => {\n  class NgSlimScrollModule {}\n\n  NgSlimScrollModule.ɵfac = function NgSlimScrollModule_Factory(t) {\n    return new (t || NgSlimScrollModule)();\n  };\n\n  NgSlimScrollModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgSlimScrollModule\n  });\n  NgSlimScrollModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return NgSlimScrollModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgSlimScrollModule, {\n    declarations: [SlimScrollDirective],\n    exports: [SlimScrollDirective]\n  });\n})();\n/*\n * Public API Surface of ngx-slimscroll\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NgSlimScrollModule, SLIMSCROLL_DEFAULTS, SlimScrollDirective, SlimScrollEvent, SlimScrollOptions, SlimScrollState, easing, ɵ0, ɵ1, ɵ10, ɵ11, ɵ12, ɵ2, ɵ3, ɵ4, ɵ5, ɵ6, ɵ7, ɵ8, ɵ9 }; //# sourceMappingURL=ngx-slimscroll.js.map","map":null,"metadata":{},"sourceType":"module"}